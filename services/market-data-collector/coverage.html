
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>backoff: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/YaganovValera/analytics-system/services/market-data-collector/pkg/backoff/backoff.go (86.7%)</option>
				
				<option value="file1">github.com/YaganovValera/analytics-system/services/market-data-collector/pkg/binance/ws.go (73.9%)</option>
				
				<option value="file2">github.com/YaganovValera/analytics-system/services/market-data-collector/pkg/kafka/producer.go (51.5%)</option>
				
				<option value="file3">github.com/YaganovValera/analytics-system/services/market-data-collector/pkg/logger/logger.go (85.4%)</option>
				
				<option value="file4">github.com/YaganovValera/analytics-system/services/market-data-collector/pkg/telemetry/otel.go (84.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package backoff

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/YaganovValera/analytics-system/services/market-data-collector/pkg/logger"
        "github.com/cenkalti/backoff/v4"
        "github.com/prometheus/client_golang/prometheus"
        "go.uber.org/zap"
)

// Config holds parameters for exponential backoff retry.
type Config struct {
        InitialInterval     time.Duration // default: 1s
        RandomizationFactor float64       // default: 0.5
        Multiplier          float64       // default: 2.0
        MaxInterval         time.Duration // default: 30s
        MaxElapsedTime      time.Duration // default: unlimited
        PerAttemptTimeout   time.Duration // default: unlimited
}

// RetryableFunc defines the operation to retry.
type RetryableFunc func(ctx context.Context) error

// ErrMaxRetries indicates retries exhausted.
type ErrMaxRetries struct {
        Err      error
        Attempts int
}

func (e *ErrMaxRetries) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("backoff: %d attempts failed: %v", e.Attempts, e.Err)
}</span>
func (e *ErrMaxRetries) Unwrap() error <span class="cov0" title="0">{ return e.Err }</span>

var (
        retriesTotal   prometheus.Counter
        failuresTotal  prometheus.Counter
        successesTotal prometheus.Counter
        delayHistogram prometheus.Histogram
        registerOnce   sync.Once
)

func initMetrics() <span class="cov8" title="1">{
        retriesTotal = prometheus.NewCounter(prometheus.CounterOpts{
                Namespace: "collector", Subsystem: "backoff", Name: "retries_total",
                Help: "Number of retry attempts",
        })
        failuresTotal = prometheus.NewCounter(prometheus.CounterOpts{
                Namespace: "collector", Subsystem: "backoff", Name: "failures_total",
                Help: "Number of operations giving up after retries",
        })
        successesTotal = prometheus.NewCounter(prometheus.CounterOpts{
                Namespace: "collector", Subsystem: "backoff", Name: "successes_total",
                Help: "Number of operations succeeded",
        })
        delayHistogram = prometheus.NewHistogram(prometheus.HistogramOpts{
                Namespace: "collector", Subsystem: "backoff", Name: "retry_delay_seconds",
                Help:    "Histogram of retry delays in seconds",
                Buckets: prometheus.DefBuckets,
        })
}</span>

// Execute runs fn with exponential backoff and collects metrics.
// Returns ErrMaxRetries if all attempts fail.
func Execute(ctx context.Context, cfg Config, log *logger.Logger, fn RetryableFunc) error <span class="cov8" title="1">{
        // register metrics once
        registerOnce.Do(func() </span><span class="cov8" title="1">{
                initMetrics()
                prometheus.MustRegister(retriesTotal, failuresTotal, successesTotal, delayHistogram)
        }</span>)

        // apply defaults
        <span class="cov8" title="1">if cfg.InitialInterval &lt;= 0 </span><span class="cov8" title="1">{
                cfg.InitialInterval = time.Second
        }</span>
        <span class="cov8" title="1">if cfg.RandomizationFactor &lt;= 0 </span><span class="cov8" title="1">{
                cfg.RandomizationFactor = 0.5
        }</span>
        <span class="cov8" title="1">if cfg.Multiplier &lt;= 0 </span><span class="cov8" title="1">{
                cfg.Multiplier = 2.0
        }</span>
        <span class="cov8" title="1">if cfg.MaxInterval &lt;= 0 </span><span class="cov8" title="1">{
                cfg.MaxInterval = 30 * time.Second
        }</span>

        // build backoff policy
        <span class="cov8" title="1">bo := backoff.NewExponentialBackOff()
        bo.InitialInterval = cfg.InitialInterval
        bo.RandomizationFactor = cfg.RandomizationFactor
        bo.Multiplier = cfg.Multiplier
        bo.MaxInterval = cfg.MaxInterval
        if cfg.MaxElapsedTime &gt; 0 </span><span class="cov8" title="1">{
                bo.MaxElapsedTime = cfg.MaxElapsedTime
        }</span> else<span class="cov0" title="0"> {
                bo.MaxElapsedTime = backoff.Stop 
        }</span>
        

        // wrap with context
        <span class="cov8" title="1">boCtx := backoff.WithContext(bo, ctx)
        attempts := 0

        // define operation
        operation := func() error </span><span class="cov8" title="1">{
                attempts++
                // per-attempt timeout
                if cfg.PerAttemptTimeout &gt; 0 </span><span class="cov0" title="0">{
                        atCtx, cancel := context.WithTimeout(ctx, cfg.PerAttemptTimeout)
                        defer cancel()
                        return fn(atCtx)
                }</span>
                <span class="cov8" title="1">return fn(ctx)</span>
        }

        // notify on retry
        <span class="cov8" title="1">notify := func(err error, delay time.Duration) </span><span class="cov8" title="1">{
                retriesTotal.Inc()
                delayHistogram.Observe(delay.Seconds())
                log.Warn("backoff retry",
                        zap.Error(err),
                        zap.Duration("delay", delay),
                        zap.Int("attempt", attempts),
                )
        }</span>

        // run retry
        <span class="cov8" title="1">err := backoff.RetryNotify(operation, boCtx, notify)
        if err != nil </span><span class="cov8" title="1">{
                failuresTotal.Inc()
                log.Error("backoff give up",
                        zap.Error(err),
                        zap.Int("attempts", attempts),
                )
                return &amp;ErrMaxRetries{Err: err, Attempts: attempts}
        }</span>

        <span class="cov8" title="1">successesTotal.Inc()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// services/market-data-collector/pkg/binance/ws.go
package binance

import (
        "context"
        "encoding/json"
        "fmt"
        "sync"
        "sync/atomic"
        "time"

        "github.com/gorilla/websocket"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/trace"

        "github.com/YaganovValera/analytics-system/services/market-data-collector/pkg/backoff"
        "github.com/YaganovValera/analytics-system/services/market-data-collector/pkg/logger"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
        "go.uber.org/zap"
)

var (
        wsConnects = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "collector", Subsystem: "binance_ws", Name: "connects_total",
                Help: "Total WebSocket connection attempts",
        })
        wsConnectErrors = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "collector", Subsystem: "binance_ws", Name: "connect_errors_total",
                Help: "Total WebSocket connection errors on first try",
        })
        wsReconnects = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "collector", Subsystem: "binance_ws", Name: "reconnects_total",
                Help: "Total WebSocket reconnections after read-loop failures",
        })
        wsMessages = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "collector", Subsystem: "binance_ws", Name: "messages_received_total",
                Help: "Total messages received from WebSocket",
        })
        wsSubscribeErrors = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "collector", Subsystem: "binance_ws", Name: "subscribe_errors_total",
                Help: "Total subscription errors",
        })
        wsReadErrors = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "collector", Subsystem: "binance_ws", Name: "read_errors_total",
                Help: "Total read errors from WebSocket",
        })
        wsPingErrors = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "collector", Subsystem: "binance_ws", Name: "ping_errors_total",
                Help: "Total ping failures",
        })
        wsBufferDrops = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "collector", Subsystem: "binance_ws", Name: "buffer_drops_total",
                Help: "Number of messages dropped because buffer was full",
        })
)

var tracer = otel.Tracer("binance-ws")

// RawMessage несёт JSON-байты и тип события.
type RawMessage struct {
        Data []byte
        Type string
}

// Config задаёт WS параметры.
type Config struct {
        URL              string
        Streams          []string
        BufferSize       int
        ReadTimeout      time.Duration
        SubscribeTimeout time.Duration
        BackoffConfig    backoff.Config
}

func (c *Config) applyDefaults() <span class="cov8" title="1">{
        if c.BufferSize &lt;= 0 </span><span class="cov8" title="1">{
                c.BufferSize = 100
        }</span>
        <span class="cov8" title="1">if c.ReadTimeout &lt;= 0 </span><span class="cov8" title="1">{
                c.ReadTimeout = 30 * time.Second
        }</span>
        <span class="cov8" title="1">if c.SubscribeTimeout &lt;= 0 </span><span class="cov8" title="1">{
                c.SubscribeTimeout = 5 * time.Second
        }</span>
}

func (c *Config) validate() error <span class="cov8" title="1">{
        if c.URL == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("binance-ws: URL is required")
        }</span>
        <span class="cov8" title="1">if len(c.Streams) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("binance-ws: at least one stream is required")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

type binanceConnector struct {
        cfg         Config
        log         *logger.Logger
        subscribeID uint64

        mu         sync.Mutex
        conn       *websocket.Conn
        cancelPing context.CancelFunc

        closed atomic.Bool
}

func NewConnector(cfg Config, log *logger.Logger) (Connector, error) <span class="cov8" title="1">{
        cfg.applyDefaults()
        if err := cfg.validate(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;binanceConnector{
                cfg: cfg,
                log: log.Named("binance-ws"),
        }, nil</span>
}

func (c *binanceConnector) Stream(ctx context.Context) (&lt;-chan RawMessage, error) <span class="cov8" title="1">{
        ch := make(chan RawMessage, c.cfg.BufferSize)
        go c.run(ctx, ch)
        return ch, nil
}</span>

func (c *binanceConnector) Close() error <span class="cov0" title="0">{
        c.closed.Store(true)
        c.mu.Lock()
        if c.cancelPing != nil </span><span class="cov0" title="0">{
                c.cancelPing()
        }</span>
        <span class="cov0" title="0">if c.conn != nil </span><span class="cov0" title="0">{
                _ = c.conn.Close()
        }</span>
        <span class="cov0" title="0">c.mu.Unlock()
        return nil</span>
}

func (c *binanceConnector) run(ctx context.Context, ch chan&lt;- RawMessage) <span class="cov8" title="1">{
        defer close(ch)
        for </span><span class="cov8" title="1">{
                // проверяем стоп-флаги
                if ctx.Err() != nil || c.closed.Load() </span><span class="cov8" title="1">{
                        c.log.Info("ws: stopping run loop")
                        return
                }</span>

                // 1) Connect
                <span class="cov8" title="1">wsConnects.Inc()
                ctxConn, spanConn := tracer.Start(ctx, "WS.Connect",
                        trace.WithAttributes(attribute.String("url", c.cfg.URL)))
                conn, err := c.connect(ctxConn)
                spanConn.End()
                if err != nil </span><span class="cov0" title="0">{
                        wsConnectErrors.Inc()
                        c.log.Error("ws: connect failed", zap.Error(err))
                        return // без инкремента reconnects: это первая попытка
                }</span>

                <span class="cov8" title="1">c.mu.Lock()
                c.conn = conn
                c.mu.Unlock()
                c.log.Info("ws: connected", zap.String("url", c.cfg.URL))

                // 2) Pinger
                cancelPing := c.startPinger(ctx, conn)
                c.mu.Lock()
                c.cancelPing = cancelPing
                c.mu.Unlock()

                // 3) Subscribe с ретраями
                if ctx.Err() != nil || c.closed.Load() </span><span class="cov0" title="0">{
                        cancelPing()
                        _ = conn.Close()
                        return
                }</span>
                <span class="cov8" title="1">ctxSub, spanSub := tracer.Start(ctx, "WS.Subscribe")
                err = backoff.Execute(ctxSub, c.cfg.BackoffConfig, c.log, func(ctx context.Context) error </span><span class="cov8" title="1">{
                        return c.subscribe(ctx, conn)
                }</span>)
                <span class="cov8" title="1">spanSub.End()
                if err != nil </span><span class="cov0" title="0">{
                        wsSubscribeErrors.Inc()
                        c.log.Error("ws: subscribe failed", zap.Error(err))
                        cancelPing()
                        _ = conn.Close()
                        return // не инкрементим reconnects: подписка вовсе не удалась
                }</span>

                // 4) ReadLoop
                <span class="cov8" title="1">ctxRead, spanRead := tracer.Start(ctx, "WS.ReadLoop")
                if err := c.readLoop(ctxRead, conn, ch); err != nil </span><span class="cov8" title="1">{
                        wsReadErrors.Inc()
                        spanRead.RecordError(err)
                        c.log.Warn("ws: read loop error, reconnecting", zap.Error(err))
                        wsReconnects.Inc() // только здесь — реальное переподключение
                }</span>
                <span class="cov8" title="1">spanRead.End()

                // Cleanup перед новой итерацией
                cancelPing()
                _ = conn.Close()</span>
        }
}

func (c *binanceConnector) connect(ctx context.Context) (*websocket.Conn, error) <span class="cov8" title="1">{
        var conn *websocket.Conn
        err := backoff.Execute(ctx, c.cfg.BackoffConfig, c.log, func(ctx context.Context) error </span><span class="cov8" title="1">{
                var err error
                conn, _, err = websocket.DefaultDialer.DialContext(ctx, c.cfg.URL, nil)
                return err
        }</span>)
        <span class="cov8" title="1">return conn, err</span>
}

func (c *binanceConnector) startPinger(ctx context.Context, conn *websocket.Conn) context.CancelFunc <span class="cov8" title="1">{
        conn.SetReadDeadline(time.Now().Add(c.cfg.ReadTimeout))
        conn.SetPongHandler(func(string) error </span><span class="cov0" title="0">{
                return conn.SetReadDeadline(time.Now().Add(c.cfg.ReadTimeout))
        }</span>)

        <span class="cov8" title="1">pingCtx, cancel := context.WithCancel(ctx)
        ticker := time.NewTicker(c.cfg.ReadTimeout / 3)
        go func() </span><span class="cov8" title="1">{
                defer ticker.Stop()
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-pingCtx.Done():<span class="cov8" title="1">
                                return</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                conn.SetWriteDeadline(time.Now().Add(1 * time.Second))
                                if err := conn.WriteControl(websocket.PingMessage, nil, time.Now().Add(1*time.Second)); err != nil </span><span class="cov0" title="0">{
                                        wsPingErrors.Inc()
                                        c.log.Warn("ws: ping failed", zap.Error(err))
                                }</span>
                        }
                }
        }()
        <span class="cov8" title="1">return cancel</span>
}

func (c *binanceConnector) subscribe(ctx context.Context, conn *websocket.Conn) error <span class="cov8" title="1">{
        if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">id := atomic.AddUint64(&amp;c.subscribeID, 1)
        req := map[string]interface{}{
                "method": "SUBSCRIBE",
                "params": c.cfg.Streams,
                "id":     id,
        }
        conn.SetWriteDeadline(time.Now().Add(c.cfg.SubscribeTimeout))
        return conn.WriteJSON(req)</span>
}

func (c *binanceConnector) readLoop(ctx context.Context, conn *websocket.Conn, ch chan&lt;- RawMessage) error <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                if err := ctx.Err(); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">_, bytes, err := conn.ReadMessage()
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">wsMessages.Inc()

                var env struct {
                        Data json.RawMessage `json:"data"`
                }
                if err := json.Unmarshal(bytes, &amp;env); err != nil </span><span class="cov0" title="0">{
                        c.log.Warn("ws: invalid envelope", zap.Error(err))
                        continue</span>
                }

                <span class="cov8" title="1">msgType := "unknown"
                var meta struct {
                        Event string `json:"e"`
                }
                if err := json.Unmarshal(env.Data, &amp;meta); err == nil &amp;&amp; meta.Event != "" </span><span class="cov8" title="1">{
                        msgType = meta.Event
                }</span>

                <span class="cov8" title="1">select </span>{
                case ch &lt;- RawMessage{Data: env.Data, Type: msgType}:<span class="cov8" title="1"></span>
                default:<span class="cov0" title="0">
                        wsBufferDrops.Inc()
                        c.log.Warn("ws: buffer full, dropping message", zap.String("type", msgType))</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// services/market-data-collector/pkg/kafka/producer.go
package kafka

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/IBM/sarama"
        "github.com/dnwe/otelsarama"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/trace"
        "go.uber.org/zap"

        "github.com/YaganovValera/analytics-system/services/market-data-collector/pkg/backoff"
        "github.com/YaganovValera/analytics-system/services/market-data-collector/pkg/logger"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
        producerConnectAttempts = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "collector", Subsystem: "kafka_producer", Name: "connect_attempts_total",
                Help: "Total number of attempts to connect Kafka producer",
        })
        producerConnectFailures = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "collector", Subsystem: "kafka_producer", Name: "connect_failures_total",
                Help: "Total number of failed Kafka producer connects",
        })
        producerPublishSuccess = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "collector", Subsystem: "kafka_producer", Name: "publish_success_total",
                Help: "Total number of successful Kafka publishes",
        })
        producerPublishErrors = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "collector", Subsystem: "kafka_producer", Name: "publish_errors_total",
                Help: "Total number of failed Kafka publishes",
        })
        producerPublishLatency = promauto.NewHistogram(prometheus.HistogramOpts{
                Namespace: "collector", Subsystem: "kafka_producer", Name: "publish_latency_seconds",
                Help:    "Histogram of Kafka publish latency in seconds",
                Buckets: prometheus.DefBuckets,
        })
        producerPingSuccess = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "collector", Subsystem: "kafka_producer", Name: "ping_success_total",
                Help: "Total number of successful Kafka pings",
        })
        producerPingErrors = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "collector", Subsystem: "kafka_producer", Name: "ping_errors_total",
                Help: "Total number of failed Kafka pings",
        })
)

var tracer = otel.Tracer("kafka-producer")

// Config хранит настройки Kafka продьюсера.
type Config struct {
        Brokers        []string
        RequiredAcks   string
        Timeout        time.Duration
        Compression    string
        FlushFrequency time.Duration
        FlushMessages  int
        Backoff        backoff.Config
}

func (c *Config) applyDefaults() <span class="cov8" title="1">{
        if c.Timeout &lt;= 0 </span><span class="cov8" title="1">{
                c.Timeout = 5 * time.Second
        }</span>
        <span class="cov8" title="1">if c.RequiredAcks == "" </span><span class="cov8" title="1">{
                c.RequiredAcks = "all"
        }</span>
        <span class="cov8" title="1">if c.Compression == "" </span><span class="cov8" title="1">{
                c.Compression = "none"
        }</span>
}

func (c *Config) validate() error <span class="cov8" title="1">{
        if len(c.Brokers) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("kafka: brokers required")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func buildSaramaConfig(c Config) (*sarama.Config, error) <span class="cov8" title="1">{
        sc := sarama.NewConfig()
        switch strings.ToLower(c.RequiredAcks) </span>{
        case "all":<span class="cov8" title="1">
                sc.Producer.RequiredAcks = sarama.WaitForAll</span>
        case "leader":<span class="cov8" title="1">
                sc.Producer.RequiredAcks = sarama.WaitForLocal</span>
        case "none":<span class="cov8" title="1">
                sc.Producer.RequiredAcks = sarama.NoResponse</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("kafka: invalid RequiredAcks %q", c.RequiredAcks)</span>
        }
        <span class="cov8" title="1">sc.Producer.Return.Successes = true
        sc.Producer.Return.Errors = true
        sc.Producer.Timeout = c.Timeout

        if f := c.FlushFrequency; f &gt; 0 </span><span class="cov0" title="0">{
                sc.Producer.Flush.Frequency = f
        }</span>
        <span class="cov8" title="1">if m := c.FlushMessages; m &gt; 0 </span><span class="cov0" title="0">{
                sc.Producer.Flush.Messages = m
        }</span>

        <span class="cov8" title="1">switch strings.ToLower(c.Compression) </span>{
        case "none":<span class="cov8" title="1">
                sc.Producer.Compression = sarama.CompressionNone</span>
        case "gzip":<span class="cov8" title="1">
                sc.Producer.Compression = sarama.CompressionGZIP</span>
        case "snappy":<span class="cov8" title="1">
                sc.Producer.Compression = sarama.CompressionSnappy</span>
        case "lz4":<span class="cov8" title="1">
                sc.Producer.Compression = sarama.CompressionLZ4</span>
        case "zstd":<span class="cov8" title="1">
                sc.Producer.Compression = sarama.CompressionZSTD</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("kafka: invalid Compression %q", c.Compression)</span>
        }

        <span class="cov8" title="1">sc.Producer.Idempotent = true
        sc.Net.MaxOpenRequests = 1

        return sc, nil</span>
}

type kafkaProducer struct {
        prod       sarama.SyncProducer
        client     sarama.Client
        logger     *logger.Logger
        backoffCfg backoff.Config
}

func NewProducer(ctx context.Context, cfg Config, log *logger.Logger) (Producer, error) <span class="cov8" title="1">{
        cfg.applyDefaults()
        if err := cfg.validate(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">log = log.Named("kafka-producer")

        sc, err := buildSaramaConfig(cfg)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">client, err := sarama.NewClient(cfg.Brokers, sc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("kafka: new client: %w", err)
        }</span>

        // при ошибке ниже обязательно закрываем client
        <span class="cov0" title="0">var syncProd sarama.SyncProducer
        connect := func(ctx context.Context) error </span><span class="cov0" title="0">{
                producerConnectAttempts.Inc()
                p, err := sarama.NewSyncProducerFromClient(client)
                if err != nil </span><span class="cov0" title="0">{
                        producerConnectFailures.Inc()
                        return err
                }</span>
                <span class="cov0" title="0">syncProd = p
                return nil</span>
        }

        <span class="cov0" title="0">ctxConn, span := tracer.Start(ctx, "Connect",
                trace.WithAttributes(attribute.StringSlice("brokers", cfg.Brokers)))
        if err := backoff.Execute(ctxConn, cfg.Backoff, log, connect); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                span.End()
                client.Close()
                log.Error("kafka: connect failed", zap.Error(err))
                return nil, fmt.Errorf("kafka: NewProducer: %w", err)
        }</span>
        <span class="cov0" title="0">span.End()

        wrapped := otelsarama.WrapSyncProducer(sc, syncProd)
        log.Info("kafka: producer ready", zap.Strings("brokers", cfg.Brokers))

        return &amp;kafkaProducer{
                prod:       wrapped,
                client:     client,
                logger:     log,
                backoffCfg: cfg.Backoff,
        }, nil</span>
}

func (k *kafkaProducer) Publish(ctx context.Context, topic string, key, value []byte) error <span class="cov8" title="1">{
        ctxPub, span := tracer.Start(ctx, "Publish",
                trace.WithAttributes(attribute.String("topic", topic)))
        start := time.Now()

        send := func(ctx context.Context) error </span><span class="cov8" title="1">{
                msg := &amp;sarama.ProducerMessage{
                        Topic: topic,
                        Key:   sarama.ByteEncoder(key),
                        Value: sarama.ByteEncoder(value),
                }
                _, _, err := k.prod.SendMessage(msg)
                return err
        }</span>

        <span class="cov8" title="1">err := backoff.Execute(ctxPub, k.backoffCfg, k.logger, send)
        lat := time.Since(start).Seconds()
        producerPublishLatency.Observe(lat)

        if err != nil </span><span class="cov0" title="0">{
                producerPublishErrors.Inc()
                span.RecordError(err)
                k.logger.Error("kafka: publish failed",
                        zap.String("topic", topic), zap.Error(err))
                span.End()
                return err
        }</span>

        <span class="cov8" title="1">producerPublishSuccess.Inc()
        k.logger.Debug("kafka: publish succeeded",
                zap.String("topic", topic), zap.Float64("latency_s", lat))
        span.End()
        return nil</span>
}

func (k *kafkaProducer) Ping() error <span class="cov0" title="0">{
        _, span := tracer.Start(context.Background(), "Ping")
        err := k.client.RefreshMetadata()
        if err != nil </span><span class="cov0" title="0">{
                producerPingErrors.Inc()
                span.RecordError(err)
        }</span> else<span class="cov0" title="0"> {
                producerPingSuccess.Inc()
        }</span>
        <span class="cov0" title="0">span.End()
        return err</span>
}

func (k *kafkaProducer) Close() error <span class="cov0" title="0">{
        errProd := k.prod.Close()
        if errProd != nil </span><span class="cov0" title="0">{
                k.logger.Error("kafka: producer close failed", zap.Error(errProd))
        }</span>
        <span class="cov0" title="0">errClient := k.client.Close()
        if errClient != nil </span><span class="cov0" title="0">{
                k.logger.Error("kafka: client close failed", zap.Error(errClient))
        }</span>
        <span class="cov0" title="0">k.logger.Info("kafka: producer closed")
        if errProd != nil </span><span class="cov0" title="0">{
                return errProd
        }</span>
        <span class="cov0" title="0">return errClient</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package logger

import (
        "context"
        "fmt"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

type contextKey string

const (
        TraceIDKey   contextKey = "trace_id"
        RequestIDKey contextKey = "request_id"
)

// Config holds parameters for logger creation.
type Config struct {
        Level   string // e.g. "debug", "info"
        DevMode bool   // true → development config
}

// Logger wraps a *zap.Logger.
type Logger struct {
        raw *zap.Logger
}

// New creates a new Logger from Config.
// It builds the zap.Config, sets level, and skips one caller frame.
func New(cfg Config) (*Logger, error) <span class="cov8" title="1">{
        zapCfg := buildZapConfig(cfg.DevMode)
        if err := setZapLevel(&amp;zapCfg, cfg.Level); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">zl, err := zapCfg.Build(zap.AddCallerSkip(1))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;Logger{raw: zl}, nil</span>
}

// buildZapConfig returns a base zap.Config for dev or prod.
func buildZapConfig(dev bool) zap.Config <span class="cov8" title="1">{
        if dev </span><span class="cov8" title="1">{
                return zap.NewDevelopmentConfig()
        }</span>
        <span class="cov8" title="1">prod := zap.NewProductionConfig()
        // sampling: log 1 in 100 after first 100 entries
        prod.Sampling = &amp;zap.SamplingConfig{Initial: 100, Thereafter: 100}
        ec := &amp;prod.EncoderConfig
        ec.TimeKey = "ts"
        ec.EncodeTime = zapcore.ISO8601TimeEncoder
        ec.CallerKey = "caller"
        ec.EncodeCaller = zapcore.ShortCallerEncoder
        ec.StacktraceKey = "stacktrace"
        return prod</span>
}

// setZapLevel parses and applies the log level.
func setZapLevel(cfg *zap.Config, level string) error <span class="cov8" title="1">{
        var lvl zapcore.Level
        if err := lvl.UnmarshalText([]byte(level)); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid log level %q: %w", level, err)
        }</span>
        <span class="cov8" title="1">cfg.Level = zap.NewAtomicLevelAt(lvl)
        return nil</span>
}

// Sync flushes any buffered log entries.
func (l *Logger) Sync() <span class="cov8" title="1">{
        _ = l.raw.Sync()
}</span>

// Named returns a sub-logger with the given name.
func (l *Logger) Named(name string) *Logger <span class="cov0" title="0">{
        return &amp;Logger{raw: l.raw.Named(name)}
}</span>

// WithContext annotates the logger with trace_id/request_id from ctx.
func (l *Logger) WithContext(ctx context.Context) *Logger <span class="cov8" title="1">{
        fields := []zap.Field{}
        if v := ctx.Value(TraceIDKey); v != nil </span><span class="cov8" title="1">{
                if tid, ok := v.(string); ok </span><span class="cov8" title="1">{
                        fields = append(fields, zap.String(string(TraceIDKey), tid))
                }</span>
        }
        <span class="cov8" title="1">if v := ctx.Value(RequestIDKey); v != nil </span><span class="cov8" title="1">{
                if rid, ok := v.(string); ok </span><span class="cov8" title="1">{
                        fields = append(fields, zap.String(string(RequestIDKey), rid))
                }</span>
        }
        <span class="cov8" title="1">if len(fields) &gt; 0 </span><span class="cov8" title="1">{
                return &amp;Logger{raw: l.raw.With(fields...)}
        }</span>
        <span class="cov0" title="0">return l</span>
}

// Info logs at Info level.
func (l *Logger) Info(msg string, fields ...zap.Field) <span class="cov8" title="1">{
        l.raw.Info(msg, fields...)
}</span>

// Debug logs at Debug level.
func (l *Logger) Debug(msg string, fields ...zap.Field) <span class="cov0" title="0">{
        l.raw.Debug(msg, fields...)
}</span>

// Warn logs at Warn level.
func (l *Logger) Warn(msg string, fields ...zap.Field) <span class="cov0" title="0">{
        l.raw.Warn(msg, fields...)
}</span>

// Error logs at Error level.
func (l *Logger) Error(msg string, fields ...zap.Field) <span class="cov0" title="0">{
        l.raw.Error(msg, fields...)
}</span>

// ContextWithTraceID returns a new context with trace ID set.
func ContextWithTraceID(ctx context.Context, tid string) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, TraceIDKey, tid)
}</span>

// ContextWithRequestID returns a new context with request ID set.
func ContextWithRequestID(ctx context.Context, rid string) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, RequestIDKey, rid)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// pkg/telemetry/otel.go
package telemetry

import (
        "context"
        "fmt"
        "time"

        "github.com/YaganovValera/analytics-system/services/market-data-collector/pkg/logger"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
        "go.opentelemetry.io/otel/propagation"
        "go.opentelemetry.io/otel/sdk/resource"
        sdktrace "go.opentelemetry.io/otel/sdk/trace"
        semconv "go.opentelemetry.io/otel/semconv/v1.26.0"
        "go.uber.org/zap"
)

// Config holds settings for OpenTelemetry initialization.
type Config struct {
        Endpoint        string        // OTLP collector (host:port)
        ServiceName     string        // e.g. "market-data-collector"
        ServiceVersion  string        // e.g. "v1.0.0"
        Insecure        bool          // true = no TLS
        ReconnectPeriod time.Duration // gRPC reconnection period
        Timeout         time.Duration // timeout for init &amp; shutdown
        SamplerRatio    float64       // [0.0 – 1.0]
}

// InitTracer configures global TracerProvider and returns a shutdown function.
func InitTracer(ctx context.Context, cfg Config, log *logger.Logger) (func(context.Context) error, error) <span class="cov8" title="1">{
        applyDefaults(&amp;cfg)
        if err := validateConfig(cfg); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Use timeout for exporter creation
        <span class="cov8" title="1">initCtx, cancel := context.WithTimeout(ctx, cfg.Timeout)
        defer cancel()

        exp, err := newExporter(initCtx, cfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("telemetry: exporter creation failed", zap.Error(err))
                return nil, fmt.Errorf("telemetry exporter: %w", err)
        }</span>

        <span class="cov8" title="1">res, err := newResource(cfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("telemetry: resource creation failed", zap.Error(err))
                return nil, fmt.Errorf("telemetry resource: %w", err)
        }</span>

        <span class="cov8" title="1">tp := newTracerProvider(exp, res, cfg)
        otel.SetTracerProvider(tp)
        otel.SetTextMapPropagator(
                propagation.NewCompositeTextMapPropagator(
                        propagation.TraceContext{}, propagation.Baggage{},
                ),
        )

        log.Info("telemetry: initialized",
                zap.String("endpoint", cfg.Endpoint),
                zap.String("service", cfg.ServiceName),
                zap.String("version", cfg.ServiceVersion),
                zap.Float64("sampler_ratio", cfg.SamplerRatio),
        )

        // shutdown func for graceful exit
        return func(ctx context.Context) error </span><span class="cov8" title="1">{
                ctx, cancel := context.WithTimeout(ctx, cfg.Timeout)
                defer cancel()
                if err := tp.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        log.Error("telemetry: shutdown failed", zap.Error(err))
                        return err
                }</span>
                <span class="cov8" title="1">log.Info("telemetry: shutdown complete")
                return nil</span>
        }, nil
}

func applyDefaults(cfg *Config) <span class="cov8" title="1">{
        if cfg.Timeout &lt;= 0 </span><span class="cov8" title="1">{
                cfg.Timeout = 5 * time.Second
        }</span>
        <span class="cov8" title="1">if cfg.ReconnectPeriod &lt;= 0 </span><span class="cov8" title="1">{
                cfg.ReconnectPeriod = 5 * time.Second
        }</span>
        <span class="cov8" title="1">if cfg.SamplerRatio &lt;= 0 || cfg.SamplerRatio &gt; 1 </span><span class="cov8" title="1">{
                cfg.SamplerRatio = 1.0
        }</span>
}

func validateConfig(cfg Config) error <span class="cov8" title="1">{
        if cfg.Endpoint == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("endpoint is required")
        }</span>
        <span class="cov8" title="1">if cfg.ServiceName == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("service name is required")
        }</span>
        <span class="cov8" title="1">if cfg.ServiceVersion == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("service version is required")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// newExporter returns a sdktrace.SpanExporter (not otlptracegrpc.Exporter).
func newExporter(ctx context.Context, cfg Config) (sdktrace.SpanExporter, error) <span class="cov8" title="1">{
        opts := []otlptracegrpc.Option{
                otlptracegrpc.WithEndpoint(cfg.Endpoint),
                otlptracegrpc.WithReconnectionPeriod(cfg.ReconnectPeriod),
        }
        if cfg.Insecure </span><span class="cov8" title="1">{
                opts = append(opts, otlptracegrpc.WithInsecure())
        }</span>
        <span class="cov8" title="1">return otlptracegrpc.New(ctx, opts...)</span>
}

func newResource(cfg Config) (*resource.Resource, error) <span class="cov8" title="1">{
        return resource.Merge(
                resource.Default(),
                resource.NewWithAttributes(
                        semconv.SchemaURL,
                        semconv.ServiceNameKey.String(cfg.ServiceName),
                        semconv.ServiceVersionKey.String(cfg.ServiceVersion),
                ),
        )
}</span>

func newTracerProvider(exp sdktrace.SpanExporter, res *resource.Resource, cfg Config) *sdktrace.TracerProvider <span class="cov8" title="1">{
        sampler := sdktrace.ParentBased(sdktrace.TraceIDRatioBased(cfg.SamplerRatio))
        return sdktrace.NewTracerProvider(
                sdktrace.WithSampler(sampler),
                sdktrace.WithBatcher(exp),
                sdktrace.WithResource(res),
        )
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
